#for (intercept, coef) in zip(clf.intercept_, clf.coef_):
#    s = "y = {0:.3f}".format(intercept)
#    for (i, c) in enumerate(coef):
#        s += " + {0:.3f} * x{1}".format(c, i)

    #print(s)
print(train_pred)

plot_decision_regions(X=X.values,
                      y=y.values,
                      clf=clf,
                      legend=2)

plt.xlabel(X.columns[0], size=14)
plt.ylabel(X.columns[1], size=14)
plt.title('SVM Decision Region Boundary', size=16)



w = clf.coef_[0]
a = -w[0]/w[1]
xx = np.linspace(min(X[:,0]),max(X[:,0]))
yy = a*xx - clf.intercept_[0]/w[1]

h0 = plt.plot(xx,yy,"k-",label = "non-weighted")
plt.scatter(X[:,0],X[:,1])
plt.ylabel("cash-ratio")
plt.xlabel("return-on-equity")
plt.legend()
plt.show()


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, random_state=12, shuffle=True, stratify=y)
print(len(X_train))
print(len(X_test))
clf = svm.SVC(kernel='rbf',C=4,gamma=1)
clf.fit(X_train, y_train)

train_pred = clf.predict(X_train)
test_pred = clf.predict(X_test)

train_precision, train_recall = product_metrics(y_train, train_pred)
test_precision, test_recall = product_metrics(y_test, test_pred)

print(train_precision,train_recall)
print(test_precision,test_precision)